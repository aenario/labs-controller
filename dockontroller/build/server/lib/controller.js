// Generated by CoffeeScript 1.7.1
var Docker, DockerCommander, EventEmitter, MAX_RELAUNCH, ProxyManager, RESTART_TIMEOUT, SPINNING_TIMEOUT, logrotate, request, utils,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Docker = require('dockerode');

ProxyManager = require('./proxymanager');

EventEmitter = require('events').EventEmitter;

logrotate = require('logrotate-stream');

request = require('request');

utils = require('../middlewares/utils');

RESTART_TIMEOUT = 3 * 1000;

MAX_RELAUNCH = 3;

SPINNING_TIMEOUT = 60 * 1000;

module.exports = DockerCommander = (function() {
  DockerCommander.prototype.socketPath = process.env.DOCKERSOCK || '/var/run/docker.sock';

  DockerCommander.prototype.version = 'v1.10';

  function DockerCommander() {
    this.handleEvent = __bind(this.handleEvent, this);
    this.handleEventsStream = __bind(this.handleEventsStream, this);
    this.docker = new Docker({
      socketPath: this.socketPath,
      version: this.version
    });
    this.proxy = new ProxyManager;
    this.expectedStops = {};
    this.relaunches = {};
    this.docker.getEvents(this.handleEventsStream);
  }

  DockerCommander.prototype.getContainerVisibleIp = function() {
    var ad, addresses, _i, _len;
    addresses = require('os').networkInterfaces()['docker0'];
    for (_i = 0, _len = addresses.length; _i < _len; _i++) {
      ad = addresses[_i];
      if (ad.family === 'IPv4') {
        return ad.address;
      }
    }
  };

  DockerCommander.prototype.waitListening = function(url, timeout, callback) {
    var i, ping;
    console.log("WAITING FOR ", url);
    i = 0;
    return (ping = function() {
      i += 500;
      if (i > timeout) {
        return callback(new Error('timeout'));
      }
      return request.get(url, function(err, response, body) {
        if (err) {
          return setTimeout(ping, 500);
        } else {
          return callback(null);
        }
      });
    })();
  };

  DockerCommander.prototype.install = function(imagename, version, params, callback) {
    var options, progress;
    console.log("INSTALLING", imagename);
    options = {
      fromImage: imagename,
      tag: version
    };
    progress = new EventEmitter();
    this.docker.createImage(options, function(err, res) {
      var lastId, step;
      lastId = null;
      step = 0;
      res.on('end', function() {
        return callback(null);
      });
      res.on('error', function(err) {
        return callback(err);
      });
      return res.on('data', function(data) {
        var e, p;
        try {
          data = JSON.parse(data.toString());
        } catch (_error) {
          e = _error;
          return;
        }
        if (data.id !== lastId) {
          lastId = data.id;
          step++;
        }
        switch (data.status) {
          case 'Pulling metadata':
            p = 0.1;
            break;
          case 'Pulling fs layer':
            p = 0.2;
            break;
          case 'Download complete':
            p = 0.9;
            break;
          case 'Downloading':
            p = 0.2 + 0.7 * (data.progressDetail.current / data.progressDetail.total);
            break;
          default:
            return;
        }
        return progress.emit('progress', {
          step: step,
          id: lastId,
          progress: p
        });
      });
    });
    return progress;
  };

  DockerCommander.prototype.updateApplication = function(imagename, env, callback) {
    return this.uninstallApplication(imagename.split('/')[1], (function(_this) {
      return function(err) {
        return _this.install(imagename, "latest", {}, function(err) {
          var options;
          options = {
            PublishAllPorts: true,
            Links: ['datasystem:datasystem'],
            Env: env
          };
          return _this.start(imagename, options, callback);
        });
      };
    })(this));
  };

  DockerCommander.prototype.uninstallApplication = function(slug, callback) {
    var container;
    container = this.docker.getContainer(slug);
    return this.stop(slug, (function(_this) {
      return function(err, image) {
        if (err) {
          return callback(err);
        }
        image = _this.docker.getImage(image);
        return image.remove(callback);
      };
    })(this));
  };

  DockerCommander.prototype.ambassador = function(slug, port, callback) {
    var ip, options;
    console.log("AMBASSADOR", slug, port);
    ip = this.getContainerVisibleIp();
    options = {
      name: slug,
      Image: 'cozy/ambassador',
      Env: "" + (slug.toUpperCase()) + "_PORT_" + port + "_TCP=tcp://" + ip + ":" + port,
      ExposedPorts: {}
    };
    options.ExposedPorts["" + port + "/tcp"] = {};
    return this.docker.createContainer(options, (function(_this) {
      return function(err) {
        var container;
        if (err) {
          return callback(err);
        }
        container = _this.docker.getContainer(slug);
        return container.start({}, callback);
      };
    })(this));
  };

  DockerCommander.prototype.start = function(imagename, params, callback) {
    var key, options, slug, value;
    slug = imagename.split('/')[1];
    options = {
      'name': slug,
      'Image': imagename,
      'Tty': false
    };
    for (key in params) {
      value = params[key];
      options[key] = value;
    }
    return this.docker.createContainer(options, (function(_this) {
      return function(err) {
        var container, logStream, logfile, singlepipe;
        console.log("STARTING", slug);
        container = _this.docker.getContainer(slug);
        logfile = "/var/log/cozy_" + slug + ".log";
        logStream = logrotate({
          file: logfile,
          size: '100k',
          keep: 3
        });
        singlepipe = {
          stream: true,
          stdout: true,
          stderr: true
        };
        return container.attach(singlepipe, function(err, stream) {
          if (err) {
            return callback(err);
          }
          stream.setEncoding('utf8');
          stream.pipe(logStream, {
            end: true
          });
          return container.start(options, function(err) {
            if (err) {
              return callback(err);
            }
            return container.inspect(function(err, data) {
              var hostPort, pingHost, pingPort, pingUrl, val, _ref;
              if (err) {
                return callback(err);
              }
              pingHost = data.NetworkSettings.IPAddress;
              _ref = data.NetworkSettings.Ports;
              for (key in _ref) {
                val = _ref[key];
                pingPort = key.split('/')[0];
                hostPort = val != null ? val[0].HostPort : void 0;
                break;
              }
              pingUrl = "http://" + pingHost + ":" + pingPort + "/";
              return _this.waitListening(pingUrl, 20000, function(err) {
                return callback(err, data, hostPort);
              });
            });
          });
        });
      };
    })(this));
  };

  DockerCommander.prototype.stop = function(slug, callback) {
    var container;
    container = this.docker.getContainer(slug);
    return container.inspect((function(_this) {
      return function(err, data) {
        var doRemove, image;
        if (err) {
          return callback(err);
        }
        image = data.Image;
        doRemove = function() {
          return container.remove(function(err) {
            if (err) {
              return callback(err);
            }
            return callback(null, image);
          });
        };
        if (!data.State.Running) {
          return doRemove();
        }
        _this.expectedStops[data.Id] = true;
        return container.stop({
          t: 1
        }, function(err) {
          if (err) {
            return callback(err);
          }
          return doRemove();
        });
      };
    })(this));
  };

  DockerCommander.prototype.exist = function(slug, callback) {
    var container;
    container = this.docker.getContainer(slug);
    return container.inspect(function(err, data) {
      return callback(null, !err);
    });
  };

  DockerCommander.prototype.running = function(callback) {
    return this.docker.listContainers(function(err, containers) {
      var result;
      if (err) {
        return callback(err);
      }
      result = containers.map(function(container) {
        return {
          name: container.Names[0].split('/').slice(-1)[0],
          port: container.Ports[0].PublicPort
        };
      });
      return callback(null, result);
    });
  };

  DockerCommander.prototype.handleEventsStream = function(err, stream) {
    if (err) {
      console.log("FAILLED TO CONNECT EVENTS", err);
      return;
    }
    stream.on('end', (function(_this) {
      return function() {
        return _this.docker.getEvents(_this.handleEventsStream);
      };
    })(this));
    return stream.on('data', this.handleEvent);
  };

  DockerCommander.prototype.handleEvent = function(data) {
    var count, e, event, timeout, _base, _name, _ref;
    try {
      event = JSON.parse(data.toString());
    } catch (_error) {
      e = _error;
      return;
    }
    if (event.status === 'stop') {
      if (this.expectedStops[event.id]) {
        this.expectedStops[event.id] = false;
        return;
      }
      console.log("Unexpected stop of ", event.from);
      if ((_base = this.relaunches)[_name = event.id] == null) {
        _base[_name] = {
          count: 0,
          timeout: null
        };
      }
      _ref = this.relaunches[event.id], count = _ref.count, timeout = _ref.timeout;
      if (timeout) {
        clearTimeout(timeout);
      }
      if (count > MAX_RELAUNCH) {
        return console.log("App ", event.from, "failled too many times");
      } else {
        return this.docker.getContainer(event.id).start((function(_this) {
          return function(err) {
            var tryAgain;
            if (err) {
              console.log("Failled to start app", event.from);
              tryAgain = function() {
                return _this.handleEvent(event);
              };
              return setTimeout(tryAgain, RESTART_TIMEOUT);
            } else {
              console.log("App restarted", event.from);
              return _this.relaunches[event.id].timeout = setTimeout(function() {
                console.log("Resetting counter for ", event.from);
                return _this.relaunches[event.id] = {
                  count: 0,
                  timeout: null
                };
              }, SPINNING_TIMEOUT);
            }
          };
        })(this));
      }
    }
  };

  DockerCommander.prototype.startCouch = function(callback) {
    return this.start('cozy/couchdb', {}, callback);
  };

  DockerCommander.prototype.startDataSystem = function(callback) {
    return this.start('cozy/datasystem', {
      Links: ['couchdb:couch'],
      Env: 'NAME=data-system TOKEN=' + utils.getToken()
    }, (function(_this) {
      return function(err, data) {
        var key, val, _ref;
        if (err) {
          return callback(err);
        }
        _this.dataSystemHost = data.NetworkSettings.IPAddress;
        _ref = data.NetworkSettings.Ports;
        for (key in _ref) {
          val = _ref[key];
          _this.dataSystemPort = key.split('/')[0];
        }
        console.log("DS STARTED", _this.dataSystemHost, _this.dataSystemPort);
        return callback(null, data);
      };
    })(this));
  };

  DockerCommander.prototype.startHome = function(callback) {
    return this.start('cozy/home', {
      PublishAllPorts: true,
      Links: ['datasystem:datasystem', 'proxy:proxy', 'controller:controller'],
      Env: 'NAME=home TOKEN=' + utils.getToken()
    }, callback);
  };

  DockerCommander.prototype.startProxy = function(homePort, callback) {
    var env, ip;
    ip = this.getContainerVisibleIp();
    env = {
      HOST: '0.0.0.0',
      DATASYSTEM_HOST: this.dataSystemHost,
      DATASYSTEM_PORT: this.dataSystemPort,
      DEFAULT_REDIRECT_PORT: homePort,
      NAME: 'proxy',
      TOKEN: utils.getToken()
    };
    return this.proxy.start(env, (function(_this) {
      return function(err) {
        if (err) {
          return callback(err);
        }
        return _this.waitListening('http://localhost:9104/', 30000, callback);
      };
    })(this));
  };

  DockerCommander.prototype.startApplication = function(slug, env, callback) {
    return this.start(slug, {
      PublishAllPorts: true,
      Links: ['datasystem:datasystem'],
      Env: env
    }, callback);
  };

  return DockerCommander;

})();
